/**
 * This script loads the geocoder and carrier data from the libphonenumber repository,
 * creates bson files from them and autogenerated the types in src/locales.ts
 */
const { readdirSync, writeFileSync, lstatSync, createReadStream, mkdirSync } = require('fs')
const { join, basename } = require('path')
const { createInterface } = require('readline')
const { execSync } = require('child_process')
const BSON = require('bson')

const isDir = (source) => lstatSync(source).isDirectory()

async function prepareLocale(localePath, locale, type) {
  const fileRe = /[0-9]+\.txt/
  const files = readdirSync(localePath).filter((source) => fileRe.test(source))
  const lineRe = /^([0-9]+)\|(.*)$/
  for (let i = 0; i < files.length; ++i) {
    const data = {}
    const file = files[i]
    const countryCode = basename(file, '.txt')
    const ccRe = new RegExp(`^${countryCode}`)
    const fileStream = createReadStream(join(localePath, file))
    const rl = createInterface({
      input: fileStream,
      crlfDelay: Infinity,
    })
    // Note: we use the crlfDelay option to recognize all instances of CR LF
    // ('\r\n') in input.txt as a single line break.
    for await (const line of rl) {
      let m
      if ((m = lineRe.exec(line)) !== null) {
        const [_, nr, description] = m
        const prefix = nr.replace(ccRe, '')
        data[prefix] = description
      }
    }
    const bData = BSON.serialize(data)
    const dataPath = join(__dirname, '/../resources', type, locale)
    mkdirSync(dataPath, { recursive: true })
    const filePath = join(dataPath, `${countryCode}.bson`)
    writeFileSync(filePath, bData)
  }
}

async function preparePath(dataPath, type) {
  const locales = readdirSync(dataPath).filter((source) => isDir(join(dataPath, source)))
  const promises = []
  for (let i = 0; i < locales.length; ++i) {
    const locale = locales[i]
    // if (locale !== 'en') continue
    const localePath = join(dataPath, locale)
    promises.push(prepareLocale(localePath, locale, type))
  }
  await Promise.all(promises)
  return { locales }
}

async function prepareTimezones() {
  const lineRe = /^([0-9]+)\|(.*)$/
  const data = {}
  const file = join(__dirname, '/../resources/libphonenumber/resources/timezones/map_data.txt')
  const fileStream = createReadStream(file)
  const rl = createInterface({
    input: fileStream,
    crlfDelay: Infinity,
  })
  // Note: we use the crlfDelay option to recognize all instances of CR LF
  // ('\r\n') in input.txt as a single line break.
  for await (const line of rl) {
    let m
    if ((m = lineRe.exec(line)) !== null) {
      const [_, prefix, description] = m
      data[prefix] = description
    }
  }
  const bData = BSON.serialize(data)
  const filePath = join(__dirname, '/../resources/timezones.bson')
  writeFileSync(filePath, bData)
}

const prepare = async () => {
  mkdirSync(join(__dirname, '/../resources/geocodes'), { recursive: true })
  mkdirSync(join(__dirname, '/../resources/carrier'), { recursive: true })
  execSync(
    `cd ${join(__dirname, '/../resources')} && git clone https://github.com/google/libphonenumber`
  )
  console.log('Preparing metadata...')
  const dataBasePath = join(__dirname, '/../resources/libphonenumber/resources')
  let generatedTypes = '/* THIS FILE IS AUTOGENERATED. */\n'

  const geocodingPath = join(dataBasePath, 'geocoding')
  const { locales: geoLocales } = await preparePath(geocodingPath, 'geocodes')
  generatedTypes += `export type GeocoderLocale = ${geoLocales.map((l) => `'${l}'`).join(' | ')};\n`

  const carrierPath = join(dataBasePath, 'carrier')
  const { locales: carrierLocales } = await preparePath(carrierPath, 'carrier')
  generatedTypes += `export type CarrierLocale = ${carrierLocales
    .map((l) => `'${l}'`)
    .join(' | ')};\n`

  await prepareTimezones()

  console.log('Creating types...')
  writeFileSync(join(__dirname, '/../src/locales.ts'), generatedTypes)
}

prepare()
  .then()
  .catch((e) => {
    console.error(`error`, e)
  })
